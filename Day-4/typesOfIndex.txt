1. Single Index:

A single-field index is an index created on one field of a document.
It improves the speed of queries that search, sort, or filter based on that specific field

> If collection is:
db.users.insertMany([
  { name: "Hiba", age: 22 },
  { name: "Aisha", age: 25 },
  { name: "Sara", age: 20 }
])

> Creating a single-field index on age:
db.users.createIndex({ age: 1 })

> When should use single-field index?
Searching by a single field (find({ city: "Kochi" }))
Sorting by a field (sort({ age: 1 }))
Range queries (age > 20)



2. Compound Index:

A compound index is an index on multiple fields where order matters. (Upto 31 fields)
MongoDB uses the left-prefix rule, means the index works only if the query starts with the first indexed field.
It optimizes filtering, sorting, and can act as a covering index.

Example:
db.users.createIndex({ city: 1, age: -1 })
First sorted by city (ASC)
Then inside each city, sorted by age (DESC)

> Why “order” matters? bcz The order of fields changes how MongoDB uses the index.

> If any field used in the index is an array, the whole index becomes a multikey index.
ex: { tags: ["mern", "node"], city: "Kochi" }
index: createIndex({ tags: 1, city: 1 })
Each element of the array creates a separate index key like => (node, Kochi), (mern, Kochi)
MongoDB automatically creates a multikey compound index.
> queries can use this multikey compound index is -
find({ tags: "node", city: "Kochi" })
Also, find({ tags: "node" })
> But does NOT work well when both fields are arrays
ex: tags: ["node", "mern"]
    skills: ["frontend", "backend"]
Index: createIndex({ tags: 1, skills: 1 })
MongoDB does NOT allow two array fields in the same compound index
This is to avoid explosions like:
node + frontend
node + backend
mern + frontend
mern + backend
Too many combinations → index becomes huge → forbidden.

> If the query needs ONLY fields inside the index, MongoDB doesn’t touch the actual document.
ex: { city: 1, age: 1 }
query: find({ city: "Kochi" }, { city: 1, age: 1, _id: 0 })
MongoDB fetches the result directly from the Index


> Left Prefix Rule:
> MongoDB can use a compound index only if the query starts from the first field(s) of the index.
> > Supported Patterns: Equality -> Sort -> Range
{ city: 1, age: 1, score: 1 }

| Query                                   | Can Use Index?                       |
| --------------------------------------- | ------------------------------------ |
| `{ city: "Kochi" }`                     |     Yes                              |
| `{ city: "Kochi", age: 22 }`            |     Yes                              |
| `{ city: "Kochi", age: 22, score: 89 }` |     Yes                              |
| `{ age: 22 }`                           |     No (city missing!)               |
| `{ score: 89 }`                         |     No                               |
| `{ age: 22, score: 89 }`                |     No                               |
| `({ city: "Kochi"}).sort(score:1)       |     No (age missed)                  |
| `( city:Kochi,age:$gt:20).sort(score:1)`|   No (after range, the next breaks)  |
| `( city:Kochi,score:$gt:20).sort(age:1)`|   Yes (age is sort, score is range)  |
| `{ age: 22, score: 89 }`                |     No                               |

> Compound Index helps with both filter + sort
Ex: db.users.createIndex({ city: 1, age: 1 })
query: db.users.find({ city: "Kochi" }).sort({ age: 1 })
> MongoDB simply reads the index from top to bottom. No need to go through whole document.
No sorting needed → very fast.



3. multikey Index:

A multikey index is used when we index a field that contains an array.
MongoDB automatically converts a normal index into a multikey index when it detects array values.
Instead of creating one index entry per document, MongoDB creates one index entry for each element in the array.
This makes quesry faster bcz Without a multikey index, querying array fields would require a full collection scan.


> example:
{
  name: "Hiba",
  skills: ["JavaScript", "Node.js", "MongoDB"]
}

db.users.createIndex({ skills: 1 })   //auto multikey
Here, MongoDB creates multiple index entries:
JavaScript
Node.js
MongoDB
All pointing to the same document.

We can query array fields as -> db.users.find({ skills: "MongoDB" })

> Multikey with nested objects:
{
  name: "Hiba",
  projects: [
    { tech: "React", year: 2024 },
    { tech: "Node", year: 2025 }
  ]
}
index: db.users.createIndex({ "projects.tech": 1 })  //this is also a multikey

> Only ONE array field allowed in a compound index
db.users.createIndex({ skills: 1, hobbies: 1 })  //not allowed if both are arrays

> Multikey indexes use more space
Because, One document -> many index entries
So, Faster reads -> Slightly slower writes



4. Text Index:

It is an index used to perform full-text search on string fields. Instead of matching exact values, 
it allows MongoDB to search inside text by analyzing words, which makes keyword-based searches fast and efficient.

When we create a text index, it internally performs several steps to enable efficient text search.
First, MongoDB tokenizes the text by breaking sentences into individual words.
Then it removes stop words like ‘is’, ‘the’, ‘and’, which don’t add much meaning.
After that, it normalizes the text by converting everything to lowercase so the search becomes case-insensitive.
Next, it applies stemming, where different word forms are reduced to a common root.
Finally, MongoDB builds an inverted index, where each word points to the documents containing it.
This structure allows MongoDB to quickly find relevant documents without scanning the entire collection, which is why text search is fast and scalable.”

We need text indexes because users search using keywords, not exact sentences and text indexes allow MongoDB 
to search inside large text fields efficiently without scanning the entire collection.

1. Tokenization:

MongoDB breaks the text into individual words (tokens)
Example text
"Looking for a backend developer with MongoDB experience"
After tokenization => looking, for, a, backend, developer, with, mongodb, experience

2. Remove stop words:

MongoDB removes common words that don’t add meaning.
Removed words => for, a, with
Remaining words => looking, backend, developer, mongodb, experience
Bcz these words appear everywhere, Indexing them wastes space and time

3. Normalization:

MongoDB converts words to a standard form.
MongoDB → mongodb
Developer → developer
So searches become case-insensitive.

4. Stemming:

MongoDB reduces words to their root form.
Examples
developing → develop
developer → develop
developed → develop
This helps MongoDB understand word variations.

5. Build Inverted Index:

MongoDB builds a structure that maps: word → document IDs
Example inverted index
backend   → doc1
developer → doc1, doc2
mongodb   → doc1
react     → doc2
This allows MongoDB to:
> Find documents by words quickly
> Without scanning all documents

> What happens on search:
When user searches text-
Query text goes through same steps
MongoDB looks up words in the inverted index
Matching documents are returned